"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = watchMutations;

var _liveSet = _interopRequireDefault(require("live-set"));

function watchMutations(input, attributeFilter, condFn) {
  return new _liveSet["default"]({
    scheduler: input.getScheduler(),
    read: function read() {
      throw new Error();
    },
    listen: function listen(setValues, controller) {
      setValues(new Set());
      var entries = new Map();

      function newEc(ec) {
        var mo = new MutationObserver(function (changes) {
          if (changes.length === 0) return;

          if (condFn(ec.el)) {
            if (!entry.passed) {
              entry.passed = true;
              controller.add(ec);
            }
          } else {
            if (entry.passed) {
              entry.passed = false;
              controller.remove(ec);
            }
          }
        });
        var entry = {
          mo: mo,
          passed: false
        };

        if (condFn(ec.el)) {
          entry.passed = true;
          controller.add(ec);
        }

        mo.observe(ec.el, {
          attributes: true,
          attributeFilter: attributeFilter
        });
        entries.set(ec, entry);
      }

      function removedEc(ec) {
        var entry = entries.get(ec);
        if (!entry) throw new Error('Should not happen: Unseen ElementContext removed');
        entry.mo.disconnect();

        if (entry.passed) {
          controller.remove(ec);
        }

        entries["delete"](ec);
      }

      var sub = input.subscribe({
        start: function start() {
          input.values().forEach(newEc);
        },
        next: function next(changes) {
          changes.forEach(function (change) {
            if (change.type === 'add') {
              newEc(change.value);
            } else if (change.type === 'remove') {
              removedEc(change.value);
            }
          });
        }
      });
      return {
        unsubscribe: function unsubscribe() {
          sub.unsubscribe();
          entries.forEach(function (_ref) {
            var mo = _ref.mo;
            mo.disconnect();
          });
        },
        pullChanges: function pullChanges() {
          sub.pullChanges(); // Don't bother doing observer.takeRecords(), we don't need that in
          // PageParserTree for how we use pullChanges().
        }
      };
    }
  });
}

module.exports = exports.default;
module.exports.default = exports.default;
//# sourceMappingURL=watchMutations.js.map