{"version":3,"sources":["../src/watcherFinderMerger.js"],"names":["watcherFinderMerger","scheduler","tagTree","tag","tagOptions","watcherSet","finder","logError","LiveSet","read","Error","listen","setValues","controller","currentElements","Set","currentElementContexts","watcherFoundElements","watcherFoundElementsMissedByFinder","sub","subscribe","start","currentValues","values","forEach","ec","add","el","next","changes","change","type","value","has","remove","error","err","complete","end","finderSchedule","fn","interval","ownedBy","runFinder","finderRunFoundElements","found","getValue","i","len","length","makeElementContext","pullChanges","flush","scheduleRepeatingFinder","unsubscribe","dispose","finderStartedTimestamp","Date","now","timeoutHandle","idleHandle","step","scheduleNextStep","time","Math","random","size","Infinity","setTimeout","global","requestIdleCallback","cancelIdleCallback","timeout","clearTimeout","_cachedParents","parents","root","current","parentElement","tagTreeNodes","getNodesForValue","node","getTag","indexOf","push","reverse"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport LiveSet from 'live-set';\nimport type Scheduler from 'live-set/Scheduler';\nimport type { TagTree } from 'tag-tree';\nimport type { TagOptions, Finder } from '.';\n\nimport type { ElementContext } from './internalTypes';\n\nexport default function watcherFinderMerger(\n  scheduler: Scheduler,\n  tagTree: TagTree<HTMLElement>,\n  tag: string,\n  tagOptions: TagOptions,\n  watcherSet: ?LiveSet<ElementContext>,\n  finder: ?Finder,\n  logError: (err: Error, el: void | HTMLElement) => void\n): LiveSet<ElementContext> {\n  return new LiveSet({\n    scheduler,\n    read() {\n      throw new Error('Should not happen');\n    },\n    listen(setValues, controller) {\n      const currentElements = new Set();\n      const currentElementContexts = new Set();\n      const watcherFoundElements = new Set();\n      const watcherFoundElementsMissedByFinder = new Set();\n\n      let sub = null;\n      if (watcherSet) {\n        sub = watcherSet.subscribe({\n          start() {\n            if (!watcherSet) throw new Error();\n            const currentValues = watcherSet.values();\n            setValues(currentValues);\n            currentValues.forEach(ec => {\n              watcherFoundElements.add(ec.el);\n              currentElements.add(ec.el);\n              currentElementContexts.add(ec);\n            });\n          },\n          next(changes) {\n            changes.forEach(change => {\n              if (change.type === 'add') {\n                const { el } = change.value;\n                watcherFoundElements.add(el);\n                if (currentElements.has(el)) {\n                  logError(\n                    new Error(\n                      `PageParserTree(${tag}) watcher found element already found by finder`\n                    ),\n                    el\n                  );\n                } else {\n                  currentElements.add(el);\n                  currentElementContexts.add(change.value);\n                  controller.add(change.value);\n                }\n              } else if (change.type === 'remove') {\n                const { el } = change.value;\n                watcherFoundElements.delete(el);\n                watcherFoundElementsMissedByFinder.delete(el);\n                if (currentElementContexts.has(change.value)) {\n                  currentElements.delete(el);\n                  currentElementContexts.delete(change.value);\n                  controller.remove(change.value);\n                } // else the ec was added by finder and it will deal with this\n              }\n            });\n          },\n          error(err) {\n            controller.error(err);\n          },\n          complete() {\n            controller.end();\n          }\n        });\n      } else {\n        setValues(new Set());\n      }\n\n      let finderSchedule = null;\n\n      if (finder) {\n        const { fn, interval } = finder;\n        const ownedBy = tagOptions.ownedBy || [];\n\n        const runFinder = () => {\n          const finderRunFoundElements = new Set();\n          const found = fn(tagTree.getValue());\n          for (let i = 0, len = found.length; i < len; i++) {\n            const el = found[i];\n            finderRunFoundElements.add(el);\n            if (!currentElements.has(el)) {\n              currentElements.add(el);\n              const ec = makeElementContext(el, tagTree, ownedBy);\n              currentElementContexts.add(ec);\n              controller.add(ec);\n              if (watcherSet) {\n                logError(\n                  new Error(\n                    `PageParserTree(${tag}) finder found element missed by watcher`\n                  ),\n                  el\n                );\n                if (sub) sub.pullChanges();\n              }\n            }\n          }\n\n          currentElementContexts.forEach(ec => {\n            const { el } = ec;\n            if (!finderRunFoundElements.has(el)) {\n              if (watcherFoundElements.has(el)) {\n                if (!watcherFoundElementsMissedByFinder.has(el)) {\n                  watcherFoundElementsMissedByFinder.add(el);\n                  logError(\n                    new Error(\n                      `PageParserTree(${tag}) watcher found element missed by finder`\n                    ),\n                    el\n                  );\n                }\n              } else {\n                currentElementContexts.delete(ec);\n                currentElements.delete(el);\n                controller.remove(ec);\n                if (sub) sub.pullChanges();\n              }\n            }\n          });\n\n          scheduler.flush();\n        };\n\n        finderSchedule = scheduleRepeatingFinder(\n          interval,\n          currentElements,\n          runFinder\n        );\n      }\n\n      return {\n        unsubscribe() {\n          if (finderSchedule != null) finderSchedule.dispose();\n          if (sub) sub.unsubscribe();\n        },\n        pullChanges() {\n          if (sub) sub.pullChanges();\n        }\n      };\n    }\n  });\n}\n\nfunction scheduleRepeatingFinder(\n  interval: $PropertyType<Finder, 'interval'>,\n  currentElements: Set<any>,\n  runFinder: () => void\n): { dispose(): void } {\n  const finderStartedTimestamp = Date.now();\n\n  let timeoutHandle = null;\n  let idleHandle = null;\n\n  const step = () => {\n    idleHandle = null;\n    runFinder();\n    scheduleNextStep();\n  };\n\n  const scheduleNextStep = () => {\n    let time;\n    if (interval == null) {\n      time = 5000 + Math.random() * 1000;\n    } else if (typeof interval === 'number') {\n      time = interval;\n    } else if (typeof interval === 'function') {\n      time = interval(\n        currentElements.size,\n        Date.now() - finderStartedTimestamp\n      );\n    } else {\n      throw new Error(`interval has wrong type: ${typeof interval}`);\n    }\n\n    // Assert to Flow that all paths should have set time to a number.\n    (time: number);\n\n    if (time === Infinity) {\n      return;\n    }\n\n    timeoutHandle = setTimeout(() => {\n      timeoutHandle = null;\n      if (global.requestIdleCallback && global.cancelIdleCallback) {\n        // Wait up to `time` milliseconds again until there's an idle moment.\n        idleHandle = global.requestIdleCallback(step, {\n          timeout: time\n        });\n      } else {\n        step();\n      }\n    }, time);\n  };\n\n  scheduleNextStep();\n\n  return {\n    dispose() {\n      if (timeoutHandle != null) clearTimeout(timeoutHandle);\n      if (idleHandle != null) global.cancelIdleCallback(idleHandle);\n    }\n  };\n}\n\nfunction makeElementContext(\n  el: HTMLElement,\n  tagTree: TagTree<HTMLElement>,\n  ownedBy: $ReadOnlyArray<string>\n): ElementContext {\n  // Don't compute parents until it's read from.\n  // This is important because nodes aren't added to the tag tree until\n  // PageParserTree iterates over the results, and some of these nodes may be\n  // owned by each other.\n  let _cachedParents = null;\n  return {\n    el,\n    get parents() {\n      if (!_cachedParents) {\n        const root = tagTree.getValue();\n        const parents = [];\n\n        let current = el.parentElement;\n        while (current) {\n          const tagTreeNodes = tagTree.getNodesForValue((current: any));\n          for (let i = 0, len = tagTreeNodes.length; i < len; i++) {\n            const node = tagTreeNodes[i];\n            const tag = node.getTag();\n            if (tag == null || ownedBy.indexOf(tag) >= 0) {\n              parents.push({ tag, node });\n              break;\n            }\n          }\n\n          if (current === root) break;\n          current = current.parentElement;\n        }\n\n        parents.reverse();\n\n        _cachedParents = parents;\n      }\n      return _cachedParents;\n    }\n  };\n}\n"],"file":"watcherFinderMerger.js"}